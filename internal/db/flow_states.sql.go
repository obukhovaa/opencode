// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: flow_states.sql

package db

import (
	"context"
	"database/sql"
)

const createFlowState = `-- name: CreateFlowState :one
INSERT INTO flow_states (
    session_id,
    root_session_id,
    flow_id,
    step_id,
    status,
    args,
    output,
    is_struct_output,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    strftime('%s', 'now'),
    strftime('%s', 'now')
) RETURNING session_id, root_session_id, flow_id, step_id, status, args, output, is_struct_output, created_at, updated_at
`

type CreateFlowStateParams struct {
	SessionID      string         `json:"session_id"`
	RootSessionID  string         `json:"root_session_id"`
	FlowID         string         `json:"flow_id"`
	StepID         string         `json:"step_id"`
	Status         string         `json:"status"`
	Args           sql.NullString `json:"args"`
	Output         sql.NullString `json:"output"`
	IsStructOutput bool           `json:"is_struct_output"`
}

func (q *Queries) CreateFlowState(ctx context.Context, arg CreateFlowStateParams) (FlowState, error) {
	row := q.queryRow(ctx, q.createFlowStateStmt, createFlowState,
		arg.SessionID,
		arg.RootSessionID,
		arg.FlowID,
		arg.StepID,
		arg.Status,
		arg.Args,
		arg.Output,
		arg.IsStructOutput,
	)
	var i FlowState
	err := row.Scan(
		&i.SessionID,
		&i.RootSessionID,
		&i.FlowID,
		&i.StepID,
		&i.Status,
		&i.Args,
		&i.Output,
		&i.IsStructOutput,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFlowStatesByRootSession = `-- name: DeleteFlowStatesByRootSession :exec
DELETE FROM flow_states WHERE root_session_id = ?
`

func (q *Queries) DeleteFlowStatesByRootSession(ctx context.Context, rootSessionID string) error {
	_, err := q.exec(ctx, q.deleteFlowStatesByRootSessionStmt, deleteFlowStatesByRootSession, rootSessionID)
	return err
}

const getFlowState = `-- name: GetFlowState :one
SELECT session_id, root_session_id, flow_id, step_id, status, args, output, is_struct_output, created_at, updated_at FROM flow_states WHERE session_id = ? LIMIT 1
`

func (q *Queries) GetFlowState(ctx context.Context, sessionID string) (FlowState, error) {
	row := q.queryRow(ctx, q.getFlowStateStmt, getFlowState, sessionID)
	var i FlowState
	err := row.Scan(
		&i.SessionID,
		&i.RootSessionID,
		&i.FlowID,
		&i.StepID,
		&i.Status,
		&i.Args,
		&i.Output,
		&i.IsStructOutput,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFlowStatesByFlowID = `-- name: ListFlowStatesByFlowID :many
SELECT session_id, root_session_id, flow_id, step_id, status, args, output, is_struct_output, created_at, updated_at FROM flow_states WHERE flow_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListFlowStatesByFlowID(ctx context.Context, flowID string) ([]FlowState, error) {
	rows, err := q.query(ctx, q.listFlowStatesByFlowIDStmt, listFlowStatesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowState{}
	for rows.Next() {
		var i FlowState
		if err := rows.Scan(
			&i.SessionID,
			&i.RootSessionID,
			&i.FlowID,
			&i.StepID,
			&i.Status,
			&i.Args,
			&i.Output,
			&i.IsStructOutput,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFlowStatesByRootSession = `-- name: ListFlowStatesByRootSession :many
SELECT session_id, root_session_id, flow_id, step_id, status, args, output, is_struct_output, created_at, updated_at FROM flow_states WHERE root_session_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListFlowStatesByRootSession(ctx context.Context, rootSessionID string) ([]FlowState, error) {
	rows, err := q.query(ctx, q.listFlowStatesByRootSessionStmt, listFlowStatesByRootSession, rootSessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowState{}
	for rows.Next() {
		var i FlowState
		if err := rows.Scan(
			&i.SessionID,
			&i.RootSessionID,
			&i.FlowID,
			&i.StepID,
			&i.Status,
			&i.Args,
			&i.Output,
			&i.IsStructOutput,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlowState = `-- name: UpdateFlowState :one
UPDATE flow_states
SET status = ?,
    output = ?,
    is_struct_output = ?,
    updated_at = strftime('%s', 'now')
WHERE session_id = ?
RETURNING session_id, root_session_id, flow_id, step_id, status, args, output, is_struct_output, created_at, updated_at
`

type UpdateFlowStateParams struct {
	Status         string         `json:"status"`
	Output         sql.NullString `json:"output"`
	IsStructOutput bool           `json:"is_struct_output"`
	SessionID      string         `json:"session_id"`
}

func (q *Queries) UpdateFlowState(ctx context.Context, arg UpdateFlowStateParams) (FlowState, error) {
	row := q.queryRow(ctx, q.updateFlowStateStmt, updateFlowState,
		arg.Status,
		arg.Output,
		arg.IsStructOutput,
		arg.SessionID,
	)
	var i FlowState
	err := row.Scan(
		&i.SessionID,
		&i.RootSessionID,
		&i.FlowID,
		&i.StepID,
		&i.Status,
		&i.Args,
		&i.Output,
		&i.IsStructOutput,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
