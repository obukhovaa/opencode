// Code generated by MockGen. DO NOT EDIT.
// Source: ./tools.go
//
// Generated by this command:
//
//	mockgen -source ./tools.go -destination ./mocks/tools_mock.go
//

// Package mock_tools is a generated GoMock package.
package mock_tools

import (
	context "context"
	reflect "reflect"

	tools "github.com/opencode-ai/opencode/internal/llm/tools"
	gomock "go.uber.org/mock/gomock"
)

// MockBaseTool is a mock of BaseTool interface.
type MockBaseTool struct {
	ctrl     *gomock.Controller
	recorder *MockBaseToolMockRecorder
	isgomock struct{}
}

// MockBaseToolMockRecorder is the mock recorder for MockBaseTool.
type MockBaseToolMockRecorder struct {
	mock *MockBaseTool
}

// NewMockBaseTool creates a new mock instance.
func NewMockBaseTool(ctrl *gomock.Controller) *MockBaseTool {
	mock := &MockBaseTool{ctrl: ctrl}
	mock.recorder = &MockBaseToolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBaseTool) EXPECT() *MockBaseToolMockRecorder {
	return m.recorder
}

// Info mocks base method.
func (m *MockBaseTool) Info() tools.ToolInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].(tools.ToolInfo)
	return ret0
}

// Info indicates an expected call of Info.
func (mr *MockBaseToolMockRecorder) Info() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockBaseTool)(nil).Info))
}

// Run mocks base method.
func (m *MockBaseTool) Run(ctx context.Context, params tools.ToolCall) (tools.ToolResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx, params)
	ret0, _ := ret[0].(tools.ToolResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockBaseToolMockRecorder) Run(ctx, params any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockBaseTool)(nil).Run), ctx, params)
}
