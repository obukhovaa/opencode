# Agentic Flows

**Date**: 2026-02-20
**Status**: Draft
**Author**: AI-assisted

## Overview

Introduce deterministic, multi-step agent workflows called Flows. A Flow is a YAML-defined directed graph of agentic steps connected by conditional routing rules, each with its own agent, prompt template, optional structured output schema, and fallback strategy. Flows run on top of the existing `agent.Run` loop, giving fine-grained control over execution order, session management, and side-effect predictability.

## Motivation

### Current State

Non-interactive execution is a single-shot agent call with no way to chain multiple agents or route based on intermediate results:

```go
// app.go — RunNonInteractive
done, err := app.ActiveAgent().Run(ctx, sess.ID, prompt)
result := <-done
fmt.Println(format.FormatOutput(content, outputFormat))
```

This creates problems:

1. **No multi-step orchestration**: Complex workflows (e.g., triage → analyse → implement → report) require manual scripting or a single monolithic prompt that is fragile and non-deterministic
2. **No conditional routing**: The agent cannot branch execution based on structured intermediate output (e.g., skip implementation if issue status is "REVIEW")
3. **No persistent execution state**: If a step fails there is no mechanism to retry, fall back to an alternative step, or resume from the failure point
4. **No side-effect predictability**: Each invocation produces wildly different intermediate actions; there is no way to enforce that specific agents handle specific phases with constrained outputs

### Desired State

Users define a YAML file describing a directed graph of steps. Each step declares an agent, a prompt template with argument substitution, optional structured output, routing rules, and fallback policy. The system executes steps in order, passes accumulated structured output forward as template arguments, persists execution state per step, and supports parallel fork/join when multiple routing rules match.

```bash
opencode -F composer-developer-react-on-jira -p "PROJ-1234"
opencode -F my-flow -s my-session-prefix -p "do the thing"
opencode -F my-flow -s my-session-prefix -D -p "restart from scratch"
opencode -F my-flow -p "PROJ-1234" -A "priority=high" -A "team=backend"
opencode -F my-flow -p "PROJ-1234" --args-file flow-args.json
```

## Research Findings

### Existing Patterns in OpenCode

| System | Discovery | Definition | Singleton | Priority |
|--------|-----------|------------|-----------|----------|
| Skills | `discoverSkills()` | Markdown + YAML frontmatter in `SKILL.md` | `sync.Once` + map cache | Project > Global > Custom paths |
| Agent Registry | `newRegistry()` | Builtins → Markdown → Config JSON | `sync.Once` + map | Config > Project MD > Global MD > Builtins |

**Key finding**: Both systems use the same layered-discovery-with-priority pattern, `sync.Once` singleton caching, and `Invalidate()` for testing. The Flow registry should follow the same pattern.

**Implication**: `FlowRegistry` can reuse the discovery and caching idioms from `internal/skill/skill.go` with minor adaptations (YAML files instead of `SKILL.md`, directory-based vs file-based identity).

### Session Management

The existing session system already supports:

| Capability | Mechanism |
|------------|-----------|
| ID-based creation | `session.Service.CreateWithID(ctx, id, title)` |
| Child sessions | `ParentSessionID`, `RootSessionID` fields |
| Session trees | `ListChildren(ctx, rootSessionID)` |
| Message copying | Messages are DB rows linkable by `session_id` |
| Deletion | `session.Service.Delete(ctx, id)` cascades messages |

**Key finding**: Flow step sessions fit naturally into the existing session tree model. Each flow execution becomes a tree rooted at the first step's session, with subsequent steps as children.

**Implication**: No schema changes are needed for sessions. Flow state tracking requires a new dedicated table.

### Agent Run Loop

```go
// agent.Service.Run returns a channel that emits exactly ONE AgentEvent
func (a *agent) Run(ctx context.Context, sessionID string, content string, attachments ...message.Attachment) (<-chan AgentEvent, error)
```

`AgentEvent` contains: `Type` (error/response/summarize), `Message`, `Error`, `StructOutput` (`*message.ToolResult`), `SessionID`, `Progress`, `Done`.

**Key finding**: `Run` creates a session-scoped goroutine, sends one result, then closes the channel. Flow orchestration wraps this — call `Run` per step, consume the single event, route to next step(s).

**Implication**: The FlowService loop is a `select` over a channel of "next steps to run", with each step spawning a goroutine that calls `agent.Run`, processes the result, and pushes successor steps back onto the channel.

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Flow definition format | YAML files (not Markdown) | Flows are pure configuration with no prose content; YAML is more natural than Markdown+frontmatter |
| Flow file identity | File basename without extension (kebab-case, e.g. `my-flow.yaml`) | Consistent with skill naming; simple, filesystem-based ID |
| Discovery priority | Project-specific overrides global (no merge) | Same pattern as skills; merging YAML flow definitions would be fragile and confusing |
| Discovery paths | `~/.config/opencode/flows/`, `~/.agents/flows/` (global); `.opencode/flows/`, `.agents/flows/` (project) | Mirrors agent registry (`~/.config/opencode/agents/`, `.opencode/agents/`) and skill (`~/.agents/skills/`, `.agents/skills/`) conventions exactly |
| Execution state storage | Dedicated `flow_states` DB table | Flow state is orthogonal to sessions/messages; separate table avoids schema pollution and allows independent querying |
| State primary key | `session_id` (FK to sessions with CASCADE DELETE) | Each step creates exactly one session; natural 1:1 mapping; cascade deletion keeps things clean |
| Parallel execution | Fork when multiple routing rules match; join when all forks complete | Matches the YAML spec's `rules` semantics; `sync.WaitGroup` provides natural join point |
| Session naming | `${prefix}-${flow_id}-${step_id}` | Deterministic, resumable; prefix is either user-supplied `-s` or timestamp |
| Session forking | Copy message history when `session.fork: true` and same agent | Different agents have different tool sets and system prompts; forking across agents would produce incoherent history |
| Arg accumulation | Structured output merged into args `map[string]any`, latest wins | Simple, predictable; each fork gets its own copy so parallel paths don't interfere |
| FlowService.Run return | Two channels: `agentEvents` and `flowStates` | Consumers need both real-time agent events (for streaming/display) and state transitions (for aggregation/persistence) |
| CLI integration | `--flow (-F)` flag on root command | Separate from `--prompt` to allow composability; flow requires a prompt to populate initial `args.prompt` |
| Non-interactive only (Phase 1) | Flow execution only in non-interactive mode | Interactive flows require TUI state management, step visualization, and user intervention points — deferred to Phase 2 |
| Rule predicate syntax | `${args.key} op value` with ops: `==`, `!=`, `=~` (regex). Regex value is delimited by `/pattern/` | Minimal but sufficient; matches the reference YAML example; regex covers complex matching; delimiters make parsing unambiguous |
| Fallback strategy | `retry` count + `delay` seconds + optional `to` step | Covers the common patterns: retry transient failures, escalate to error handler |
| Fork convergence (Phase 1) | First-to-arrive wins; duplicate step execution is skipped | Diamond patterns (A→B,C; B→D, C→D) create session ID collisions; simpler to skip than to implement join semantics; convergence deferred to Phase 2 |
| Flow result format | Always JSON envelope for aggregate; step content respects step's output format | Unambiguous machine-readable output; individual steps may produce text or structured output |
| `${args}` full dump format | JSON string | Unambiguous, LLM-parseable; consistent with structured output format |
| Initial args beyond `prompt` | Extra args passed via `--arg key=value` (repeatable flag) or JSON file via `--args-file` | Flows may define required args beyond prompt; `-p` alone is insufficient for complex flows |
| Agent validation at discovery | Warn (not error) if step references unknown agent ID | Agents may be defined in user-specific config not available at parse time; runtime resolution is the source of truth |

## Architecture

### Flow Definition (YAML)

```
┌──────────────────────────────────────────────────────────┐
│  Flow YAML File                                          │
│  ├── name: string                                        │
│  ├── disabled: bool                                      │
│  ├── description: string                                 │
│  └── flow:                                               │
│      ├── args:                                           │
│      │   └── type: object                                │
│      │       └── properties: map[string]JSONSchema        │
│      └── steps: []Step                                   │
│          ├── id: string (kebab-case, ≤64 chars)          │
│          ├── agent: string (optional, agent/subagent ID) │
│          ├── session:                                     │
│          │   └── fork: bool                              │
│          ├── prompt: string (with ${args.*} templates)   │
│          ├── output:                                     │
│          │   └── schema: JSONSchema (for struct_output)  │
│          ├── rules: []Rule                               │
│          │   ├── if: predicate string                    │
│          │   ├── then: step_id                           │
│          │   └── postpone: bool (optional)               │
│          └── fallback:                                   │
│              ├── retry: int                              │
│              ├── delay: int (seconds)                    │
│              └── to: step_id (optional)                  │
└──────────────────────────────────────────────────────────┘
```

### Discovery & Registry

```
~/.config/opencode/flows/*.yaml ─┐
~/.agents/flows/*.yaml           ├── Global (lower priority)
                                 │
.opencode/flows/*.yaml          ─┤
.agents/flows/*.yaml             ├── Project (higher priority, wins on conflict)
                                 │
                                 ▼
                    ┌─────────────────────────┐
                    │     FlowRegistry        │
                    │  sync.Once + map cache   │
                    │                         │
                    │  Get(id) → (*Flow, bool) │
                    │  List() → []Flow         │
                    │  Invalidate()            │
                    └─────────────────────────┘
```

### Execution Flow

```
   User: opencode -F my-flow -p "do stuff" [-s prefix] [-D]
                    │
                    ▼
        ┌──────────────────────┐
        │   cmd/root.go        │
        │   Parse --flow flag  │
        │   Build initial args │
        └──────────┬───────────┘
                   │
                   ▼
        ┌──────────────────────┐
        │   FlowService.Run    │
        │                      │
        │   session_id: prefix │
        │   flow_id: my-flow   │
        │   args: {prompt: ..} │
        │   fresh: (--delete)  │
        └──────────┬───────────┘
                   │
      ┌────────────┼───────────────────────┐
      │            │                       │
      ▼            ▼                       ▼
  Resolve      Build root_session_id    Fetch existing
  Flow from    ${prefix}-${flow_id}     FlowStates by
  Registry     -${steps[0].id}          root_session_id
      │            │                       │
      └────────────┼───────────────────────┘
                   │
                   ▼
         ┌─────────────────┐     If running states exist
         │  Guard: any      │────► Return states, do not
         │  running steps?  │     invoke any agents
         └────────┬────────┘
                  │ No running states
                  ▼
         ┌─────────────────┐
         │  fresh == true?  │──► Delete all FlowStates
         └────────┬────────┘    for root_session_id
                  │
                  ▼
    ┌──────────────────────────────┐
    │  nextFlowStates channel      │ ◄── seed with steps[0]
    │  (internal work queue)       │
    └─────────────┬────────────────┘
                  │
                  ▼
    ┌──────────────────────────────┐
    │  select loop                 │
    │                              │
    │  for step := range next {    │
    │    wg.Add(1)                 │
    │    go runStep(step) ─────────┼──► See "Step Execution" below
    │  }                           │
    │                              │
    │  // separate goroutine:      │
    │  wg.Wait()                   │
    │  close(nextFlowStates)       │
    │  close(agentEvents)          │
    │  close(flowStates)           │
    └──────────────────────────────┘
```

### Step Execution (per goroutine)

```
STEP 1: Resolve agent
───────────────────────
Find agent via AgentRegistry.Get(step.agent).
If step.output is defined, override AgentInfo.Output.

STEP 2: Build session
───────────────────────
session_id = ${prefix}-${flow_id}-${step.id}
If fresh: delete existing session with this ID.
If step.session.fork && previous agent matches:
  Create new session, copy previous step's messages.
Else: create or reuse session by ID.

STEP 3: Prepare prompt
───────────────────────
Substitute ${args.*} placeholders with current args.
Prepend previous step's output (if not first step).

STEP 4: Persist FlowState (status=running)
───────────────────────
Store: session_id, root_session_id, flow_id, step_id,
       status=running, args (snapshot), output=null.

STEP 5: Call agent.Run
───────────────────────
result := <-agent.Run(ctx, session_id, prompt)

STEP 6a: On error → fallback
───────────────────────
Retry up to fallback.retry times with fallback.delay.
If all retries fail:
  Update FlowState status=failed.
  If fallback.to defined: push fallback step to nextFlowStates.
  Else: send error to agentEvents, send FlowState to flowStates.

STEP 6b: On success → route
───────────────────────
Extract output: StructOutput (if available) or Message.Content().
If StructOutput: marshal to map[string]any, merge into args.
Update FlowState status=completed with output.
Evaluate rules:
  For each rule where predicate matches:
    Push matched step to nextFlowStates (parallel if >1 match).
Send AgentEvent to agentEvents.
Send FlowState to flowStates.

STEP 7: wg.Done()
```

### FlowState Database Schema

```
┌───────────────────────────────────────────────────────────────┐
│  flow_states                                                  │
│  ├── session_id       TEXT PK, FK sessions(id) CASCADE DELETE │
│  ├── root_session_id  TEXT NOT NULL, INDEX                    │
│  ├── flow_id          TEXT NOT NULL, INDEX                    │
│  ├── step_id          TEXT NOT NULL                           │
│  ├── status           TEXT NOT NULL (running|completed|failed|postponed)│
│  ├── args             TEXT (JSON map[string]any)              │
│  ├── output           TEXT NULLABLE (JSON or free-form)       │
│  ├── is_struct_output BOOLEAN NOT NULL DEFAULT FALSE          │
│  ├── created_at       INTEGER NOT NULL                        │
│  └── updated_at       INTEGER NOT NULL                        │
└───────────────────────────────────────────────────────────────┘
```

### AgentEvent Extension

```go
type AgentEvent struct {
    Type         AgentEventType
    Message      message.Message
    Error        error
    StructOutput *message.ToolResult
    SessionID    string
    Progress     string
    Done         bool
    FlowStepID   string  // NEW: set when event originates from a Flow step
}
```

## Implementation Plan

### Phase 1: Flow Definition Types and Registry

- [x] **1.1** Create `internal/flow/flow.go` with Flow definition types:
  ```go
  type Flow struct {
      ID          string
      Name        string
      Disabled    bool
      Description string
      Spec        FlowSpec
      Location    string
  }

  type FlowSpec struct {
      Args  map[string]any `yaml:"args"`
      Steps []Step         `yaml:"steps"`
  }

  type Step struct {
      ID       string        `yaml:"id"`
      Agent    string        `yaml:"agent,omitempty"`
      Session  StepSession   `yaml:"session,omitempty"`
      Prompt   string        `yaml:"prompt"`
      Output   *StepOutput   `yaml:"output,omitempty"`
      Rules    []Rule        `yaml:"rules,omitempty"`
      Fallback *Fallback     `yaml:"fallback,omitempty"`
  }

  type StepSession struct {
      Fork bool `yaml:"fork,omitempty"`
  }

  type StepOutput struct {
      Schema map[string]any `yaml:"schema"`
  }

  type Rule struct {
      If       string `yaml:"if"`
      Then     string `yaml:"then"`
      Postpone bool   `yaml:"postpone,omitempty"`
  }

  type Fallback struct {
      Retry int    `yaml:"retry"`
      Delay int    `yaml:"delay,omitempty"`
      To    string `yaml:"to,omitempty"`
  }
  ```

- [x] **1.2** Create `internal/flow/registry.go` — singleton FlowRegistry with `sync.Once`, discovery from global and project paths, YAML parsing, validation (step ID uniqueness, kebab-case, rules reference valid step IDs), and priority resolution (project wins over global).

- [x] **1.3** Add validation helpers: step ID format (kebab-case, ≤64 chars), rule `then` references existing step ID, no duplicate step IDs within a flow, flow file naming matches kebab-case, warn if a step ID appears in multiple `then` clauses across different steps (potential convergence — supported but first-to-arrive wins), warn if step references unknown agent ID (agents may be defined in user-specific config not available at parse time).

### Phase 2: Database Layer

- [x] **2.1** Create migration files for both SQLite and MySQL:
  - `internal/db/migrations/sqlite/20260220120000_add_flow_states.sql`
  - `internal/db/migrations/mysql/20260220120000_add_flow_states.sql`
  
  SQLite:
  ```sql
  -- +goose Up
  CREATE TABLE flow_states (
      session_id TEXT PRIMARY KEY REFERENCES sessions(id) ON DELETE CASCADE,
      root_session_id TEXT NOT NULL,
      flow_id TEXT NOT NULL,
      step_id TEXT NOT NULL,
      status TEXT NOT NULL DEFAULT 'running',
      args TEXT,
      output TEXT,
      is_struct_output BOOLEAN NOT NULL DEFAULT FALSE,
      created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
      updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
  );
  CREATE INDEX idx_flow_states_root_session ON flow_states(root_session_id);
  CREATE INDEX idx_flow_states_flow_id ON flow_states(flow_id);

  -- +goose Down
  DROP TABLE IF EXISTS flow_states;
  ```

- [x] **2.2** Add sqlc queries in `internal/db/sql/flow_states.sql` (and `internal/db/sql/mysql/flow_states.sql`):
  - `CreateFlowState`, `GetFlowState` (by session_id), `ListFlowStatesByRootSession`, `ListFlowStatesByFlowID`, `UpdateFlowState`, `DeleteFlowStatesByRootSession`

- [x] **2.3** Run `sqlc generate` to produce `internal/db/flow_states.sql.go` and MySQL equivalent. Update `Querier` interface and `QuerierWithTx` wrappers.

- [x] **2.4** Add `FlowState` model to `internal/db/models.go` (via sqlc generation).

### Phase 3: FlowService

- [x] **3.1** Create `internal/flow/service.go` with the `Service` interface:
  ```go
  type FlowState struct {
      SessionID      string
      RootSessionID  string
      FlowID         string
      StepID         string
      Status         FlowStatus // running | completed | failed
      Args           map[string]any
      Output         string
      IsStructOutput bool
      CreatedAt      int64
      UpdatedAt      int64
  }

  type FlowStatus string
  const (
      FlowStatusRunning    FlowStatus = "running"
      FlowStatusCompleted  FlowStatus = "completed"
      FlowStatusFailed     FlowStatus = "failed"
      FlowStatusPostponed  FlowStatus = "postponed"
  )

  type Service interface {
      Run(ctx context.Context, sessionID string, flowID string, args map[string]any, fresh bool) (<-chan agent.AgentEvent, <-chan *FlowState, error)
  }
  ```

- [x] **3.2** Implement `Run` method orchestration logic:
  - Resolve flow from `FlowRegistry`
  - Build `root_session_id` from prefix + flow ID + first step ID
  - Check for existing running states (guard against concurrent execution)
  - Handle `fresh` flag (delete existing FlowStates and sessions)
  - Initialize `nextFlowStates` channel seeded with first step
  - Spawn goroutines per step, track with `sync.WaitGroup`
  - Close all output channels when WaitGroup completes

- [x] **3.3** Implement step execution logic:
  - Agent resolution via `AgentRegistry.Get`, output schema override
  - Session creation/reuse/fork logic using `session.Service`
  - Prompt template substitution (`${args.*}` → values, `${args}` → full dump)
  - Prepend previous step output to prompt
  - FlowState persistence (create with running, update to completed/failed)
  - Error handling with retry loop and fallback routing
  - Rule evaluation with predicate parsing

- [x] **3.4** Implement rule predicate parser:
  ```go
  // Parses: "${args.workflow} == IMPLEMENTATION"
  // Parses: "${args.workflow} != SKIP"
  // Parses: "${args.workflow} =~ /IMPLEMENTATION|CORRECTION/"
  func evaluatePredicate(predicate string, args map[string]any) (bool, error)
  ```

- [x] **3.5** Add `FlowStepID` field to `AgentEvent` in `internal/llm/agent/agent.go`.

### Phase 4: CLI Integration

- [x] **4.1** Add `--flow (-F)` flag to `cmd/root.go`:
  ```go
  rootCmd.Flags().StringP("flow", "F", "", "Flow ID to execute")
  ```

- [x] **4.1b** Add `--arg (-A)` repeatable flag and `--args-file` flag to `cmd/root.go`:
  ```go
  rootCmd.Flags().StringArrayP("arg", "A", nil, "Flow argument as key=value (repeatable)")
  rootCmd.Flags().String("args-file", "", "JSON file with flow arguments")
  ```

- [x] **4.2** Wire flow execution in the non-interactive branch of `RunE`:
  - Parse `--flow` flag value
  - Build initial args from `--prompt` (`args.prompt = prompt`), then parse `--arg key=value` pairs and merge, then load and merge `--args-file` JSON (later sources win)
  - Create `FlowService` instance
  - Call `FlowService.Run(ctx, sessionID, flowID, args, deleteSession)`
  - Consume both channels, aggregate into result structure
  - Output result as JSON:
    ```json
    {
      "flow_id": "...",
      "root_session_id": "...",
      "running_steps": [...],
      "completed_steps": [...],
      "failed_steps": [...]
    }
    ```

- [x] **4.3** Refactor `RunNonInteractive` to share session creation and permission auto-approval logic with flow execution, since a flow is essentially N sequential/parallel non-interactive runs.

### Phase 5: Testing

- [x] **5.1** Unit tests for `internal/flow/registry.go`: discovery, priority resolution, validation errors, YAML parsing.

- [x] **5.2** Unit tests for rule predicate evaluation: `==`, `!=`, `=~`, missing args, invalid syntax.

- [x] **5.3** Unit tests for prompt template substitution: `${args.key}`, `${args}` dump, missing keys.

- [x] **5.4** Integration test for `FlowService.Run`: mock `agent.Service` and `session.Service`, verify step sequencing, state transitions, and parallel fork behavior.

### Phase 6: Documentation

- [x] **6.1** Create `docs/flows.md` with user-facing documentation: flow definition format, example YAML, CLI usage, session naming, resumption, and deletion behavior.

- [x] **6.2** Update `README.md` with a brief mention of flows and link to `docs/flows.md`.

## Edge Cases

### Flow with running steps from previous invocation

1. User invokes `opencode -F my-flow -p "do stuff"`
2. A step is mid-execution when the process is killed
3. User re-invokes the same command
4. `FlowService.Run` finds FlowStates with `status == running`
5. Returns existing states without invoking any agents — user must use `--delete` to force restart

### Parallel fork with shared arg keys

1. Step A produces `{workflow: "IMPL"}`, routes to steps B and C in parallel
2. Step B produces `{result: "ok"}`, step C produces `{result: "fail"}`
3. Each fork maintains its own copy of args — B's fork has `{workflow: "IMPL", result: "ok"}`, C's fork has `{workflow: "IMPL", result: "fail"}`
4. No cross-contamination between forks

### Parallel fork convergence (diamond pattern)

1. Step A routes to steps B and C in parallel (two rules match)
2. Step B completes and routes to step D
3. Step C completes and also routes to step D
4. Step B's goroutine arrives first, creates session `${prefix}-my-flow-D` and runs step D
5. Step C's goroutine arrives second, finds FlowState for step D already exists (running or completed), skips execution
6. Step D runs exactly once with the args from whichever fork arrived first
7. **Phase 2**: Proper join semantics (wait for all predecessors, merge args) can be added via a `join: true` field on Step

### Session fork with different agents

1. Step A uses agent `piano-manager`, step B has `session.fork: true` but uses agent `coder`
2. Fork is rejected because agents differ — step B creates a fresh session instead
3. Previous step output is still prepended to the prompt (always happens)

### Fallback chain

1. Step X fails, `fallback.retry: 2`, `fallback.delay: 10`, `fallback.to: error-handler`
2. Step X is retried twice with 10-second delays
3. All retries fail → FlowState updated to `failed`
4. Step `error-handler` is pushed to `nextFlowStates` and executed
5. If `error-handler` also has no fallback and fails, it becomes a terminal failure

### No rules match (terminal step)

1. Step completes successfully
2. `rules` is empty or no predicates evaluate to true
3. Step is terminal — no successor steps are pushed
4. If this is the last active goroutine, `wg.Wait()` unblocks and closes all channels

### Same session ID across invocations (resumption)

1. First run: `opencode -F my-flow -s proj123 -p "PROJ-1234"`
   - Creates sessions: `proj123-my-flow-pick-workflow`, `proj123-my-flow-analyse-issue`, etc.
2. Second run (same `-s`): `opencode -F my-flow -s proj123 -p "PROJ-1234"`
   - Finds existing sessions by ID pattern, reuses them (agent continues from previous messages)
   - FlowStates are checked — if all completed, flow starts from step[0] again with fresh state
3. Second run with delete: `opencode -F my-flow -s proj123 -D -p "PROJ-1234"`
   - Deletes all previous sessions and FlowStates, starts clean

### Disabled flow

1. Flow YAML has `disabled: true`
2. `FlowRegistry.Get("my-flow")` returns the flow but it is marked disabled
3. `FlowService.Run` checks `flow.Disabled` and returns an error immediately

## Open Questions

1. **~~Should the flow result format be configurable (text vs JSON)?~~** — **Resolved**
   - Always JSON for the aggregate envelope; individual step content respects the step's output format

2. **Should flows support a `timeout` per step?**
   - The reference YAML example doesn't include timeouts
   - Long-running steps could block the entire flow indefinitely
   - **Recommendation**: Defer to Phase 2. Context cancellation provides a coarse mechanism; per-step timeouts can be added later via a `timeout` field on Step

3. **~~How should `${args}` (full dump) be formatted?~~** — **Resolved**
   - JSON string — it's unambiguous and the LLM can parse it reliably

4. **Should FlowStates be queryable via a CLI subcommand (e.g., `opencode flow status`)?**
   - Useful for debugging and monitoring long-running flows
   - **Recommendation**: Defer. The JSON output from `Run` provides status. A dedicated subcommand can be added when interactive flow support is built

5. **Should the flow be interruptible mid-step (e.g., Ctrl+C stops the current step but not the flow)?**
   - Currently context cancellation stops everything
   - **Recommendation**: Defer. Phase 1 uses context cancellation as a full stop. Graceful step-level interruption is a Phase 2 concern

6. **How should flow-level permissions work?**
   - Should flows auto-approve all permissions (like current non-interactive mode)?
   - Or should per-step agents respect their configured permission rules?
   - **Recommendation**: Auto-approve all permissions for flow sessions, matching current non-interactive behavior. Flows are inherently automated; requiring user approval would defeat the purpose

7. **How should the aggregate flow output be constructed?**
   - If the flow has multiple terminal steps (parallel forks that don't converge), which step's output is the "final" result?
   - Options: (a) All terminal step outputs collected in an array, (b) Last-completed step output, (c) Explicit `final: true` marker on one step
   - **Recommendation**: Collect all terminal step outputs in the JSON envelope's `completed_steps` array. The consumer decides which to use. No single "final" output.

## Success Criteria

- [ ] YAML flow files are discovered from global (`~/.config/opencode/flows/`, `~/.agents/flows/`) and project (`.opencode/flows/`, `.agents/flows/`) paths with project priority
- [ ] `FlowRegistry` provides `Get(id)` and `List()` with singleton caching and `Invalidate()` for tests
- [ ] Flow validation catches: duplicate step IDs, invalid kebab-case, rules referencing non-existent steps
- [ ] `flow_states` table exists in both SQLite and MySQL with proper FK cascade and indexes
- [ ] `FlowService.Run` executes steps sequentially following routing rules
- [ ] Parallel forking works when multiple rules match a single step
- [ ] `${args.*}` template substitution works in prompts, including accumulated structured output
- [ ] Fallback retry + delay + fallback-to-step works correctly
- [ ] `--flow (-F)` CLI flag triggers flow execution in non-interactive mode
- [ ] `--arg (-A)` repeatable flag and `--args-file` populate initial flow args beyond `prompt`
- [ ] Session naming follows `${prefix}-${flow_id}-${step_id}` pattern
- [ ] Session reuse, forking, and `--delete` fresh start all work correctly
- [ ] `AgentEvent.FlowStepID` is populated for flow-originated events
- [ ] Unit tests cover registry, predicates, template substitution, and orchestration
- [ ] `docs/flows.md` documents YAML format, CLI usage, and behavior
- [ ] All existing tests pass (`make test`)

## References

- `internal/skill/skill.go` — Discovery and singleton registry pattern to follow
- `internal/agent/registry.go` — AgentInfo, AgentRegistry interface, Output struct
- `internal/llm/agent/agent.go` — Agent Service interface, Run method, AgentEvent struct
- `internal/llm/tools/struct_output.go` — Structured output tool, schema-to-params conversion
- `internal/session/session.go` — Session Service interface, CreateWithID, session tree model
- `internal/app/app.go` — RunNonInteractive method to refactor/reuse
- `cmd/root.go` — CLI flag definitions, non-interactive execution branch
- `internal/db/provider.go` — DB provider interface, migration wiring
- `internal/db/migrations/sqlite/` — Migration file naming convention
- `internal/db/sql/sessions.sql` — sqlc query file pattern to follow
- `internal/pubsub/events.go` — Event system for pub/sub channels
- `~/.agents/flows/composer-developer-react-on-jira.yaml` — Reference flow YAML example
