# Delete Tool

**Date**: 2026-02-10
**Status**: Implemented
**Author**: AI-assisted

## Overview

Add a dedicated `delete` tool that removes files and directories from the filesystem while properly tracking changes in the file history system and in-memory file records. Supports the extended permission model with path-based glob patterns for granular access control.

## Motivation

### Current State

When an agent needs to delete a file, the only option is the bash tool:

```go
// bash.go — executes arbitrary commands, no file tracking
func (b *bashTool) Run(ctx context.Context, call ToolCall) (ToolResponse, error) {
    // Executes command (e.g., "rm file.go")
    // Does NOT call history.Service
    // Does NOT update fileRecords map
    // Does NOT publish pubsub events
    return NewTextResponse(output), nil
}
```

Meanwhile, every other file-modifying tool tracks changes:

```go
// write.go, edit.go, multiedit.go, patch.go — all follow this pattern:
file, err := w.files.GetByPathAndSession(ctx, filePath, sessionID)
if err != nil {
    w.files.Create(ctx, sessionID, filePath, oldContent)     // "initial" version
}
w.files.CreateVersion(ctx, sessionID, filePath, newContent)  // "v1", "v2", etc.
recordFileWrite(filePath)
recordFileRead(filePath)
```

The patch tool already handles `ActionDelete` correctly as part of multi-file patches:

```go
// patch.go — delete within a patch commit
if change.Type == diff.ActionDelete {
    p.files.CreateVersion(ctx, sessionID, absPath, "")  // stores empty content
    os.Remove(absPath)
    recordFileWrite(absPath)
    recordFileRead(absPath)
}
```

This creates problems:

1. **Invisible deletions**: Files deleted via `rm` in bash don't appear in the sidebar's modified files list because `history.ListLatestSessionTreeFiles()` has no record of them.
2. **Broken file tracking**: The in-memory `fileRecords` map retains stale read/write times for deleted files, which can cause confusing errors if the agent later recreates the file.
3. **No granular permission control**: Bash permissions operate on the command string (`"rm *": "deny"`), not on file paths. You can't express "allow deleting files in `tmp/` but deny deleting `*.go`" without fragile command-pattern matching.
4. **No directory support with tracking**: Deleting a directory via `rm -rf` gives zero visibility into which files were removed. The sidebar and history lose all context.

### Desired State

```go
// delete.go — dedicated tool with full tracking
type DeleteParams struct {
    Path string `json:"path"`
}

// Handles both files and directories
// Tracks every deleted file in history (content → "")
// Supports path-based permission patterns like write/edit tools
```

```json
{
  "permission": {
    "rules": {
      "delete": {
        "*": "ask",
        "tmp/*": "allow",
        "*.go": "deny"
      }
    }
  }
}
```

Agents use the delete tool instead of `rm` via bash. Deleted files appear in the sidebar with all-removal diffs. Permissions are path-based, matching the pattern used by `write` and `edit` tools.

## Research Findings

### How Other Tools Handle File Tracking

| Tool | File Read | Permission | Filesystem | History | In-Memory | LSP |
|---|---|---|---|---|---|---|
| Write | Read old content | `evaluateToolPermission(ctx, "write", filePath)` | `os.WriteFile()` | Create initial + CreateVersion | `recordFileWrite` + `recordFileRead` | `waitForLspDiagnostics` |
| Edit | Read old content | `evaluateToolPermission(ctx, "edit", filePath)` | `os.WriteFile()` | Create initial + CreateVersion | `recordFileWrite` + `recordFileRead` | `waitForLspDiagnostics` |
| Patch (delete) | Read old content | `permissions.Request()` with action "delete" | `os.Remove()` | Create initial + CreateVersion("") | `recordFileWrite` + `recordFileRead` | N/A |
| Bash | N/A | `evaluateToolPermission(ctx, "bash", command)` | Arbitrary | **None** | **None** | N/A |

**Key finding**: The patch tool's delete path is the closest reference implementation. The delete tool essentially extracts and extends that pattern into a standalone tool with directory support.

### Claude Code's Approach

Claude Code does not have a dedicated delete tool. File deletion goes through bash (`rm`). This means Claude Code also has the same file tracking gap — but Claude Code doesn't have OpenCode's file history system, so the impact is different.

**Implication**: We have the opportunity to improve on the industry standard by providing tracked deletions.

### Permission Model Comparison

| Tool | Permission Input | Pattern Example |
|---|---|---|
| bash | Command string | `"rm -rf *": "deny"` |
| write | File path | `"*.go": "allow"` |
| edit | File path | `"src/**/*.go": "allow"` |
| read (view) | File path | `"*.env": "deny"` |
| **delete** (proposed) | **File path** | **`"tmp/*": "allow"`, `"*.go": "deny"`** |

**Key finding**: The permission system in `evaluate.go` already supports path-based glob matching via `MatchWildcard()`. The `evaluateToolPermission()` function takes a `toolName` and `input` string — for delete, the input would be the file/directory path, exactly like write and edit.

**Implication**: No changes to the permission evaluation engine are needed. The delete tool just needs to call `evaluateToolPermission(ctx, "delete", path)` and it gets full glob-pattern support for free.

## Design Decisions

| Decision | Choice | Rationale |
|---|---|---|
| Single `path` parameter | `path: string` (file or directory) | Simple interface. Tool auto-detects file vs directory via `os.Stat()` |
| Directory deletion strategy | Walk directory tree, record each file in history, then `os.RemoveAll()` | Preserves full visibility of what was deleted |
| Permission granularity | Single permission check on the target path | For directories, check the directory path. Individual files within are covered by the directory permission. Avoids N permission prompts for large directories |
| History tracking for directories | Record each file individually with content → "" | Matches sidebar rendering logic which operates per-file |
| Permission input | Absolute file path | Consistent with write/edit tools which pass `filePath` to `evaluateToolPermission()` |
| Working directory restriction | Reject paths outside `config.WorkingDirectory()` | Safety guard — prevents deleting system files. Can be overridden by permissions |
| Tool name | `"delete"` | Clear, matches the action. Distinct from bash's `rm` |
| Agent availability | Coder + Workhorse (same as write/edit/patch) | These are the agents that modify files |
| LSP diagnostics | Not needed after deletion | No file to diagnose. LSP servers handle file deletion events via watchers |

## Architecture

### Delete Tool — Execution Flow

```
LLM sends delete tool call
    │
    ├── path: "/path/to/target"
    │
    ▼
STEP 1: Validate & Resolve Path
─────────────────────────────────
- Resolve to absolute path (join with WorkingDirectory if relative)
- os.Stat() to check existence
- Reject if path doesn't exist
- Reject if path is outside WorkingDirectory()
- Determine: file or directory?

STEP 2: Permission Check
──────────────────────────
- evaluateToolPermission(ctx, "delete", absPath)
  - Checks agent-specific perms: agents.coder.permission.delete
  - Checks global perms: permission.rules.delete
  - Falls through to "ask" default
- If "allow" → proceed
- If "deny" → return ErrorPermissionDenied
- If "ask" → interactive permission request with diff preview

STEP 3a: File Deletion
────────────────────────
- Read current content
- Record in history:
  - GetByPathAndSession() → if missing, Create(sessionID, path, content)
  - CreateVersion(sessionID, path, "")  ← empty = deleted
- os.Remove(path)
- recordFileWrite(path) + recordFileRead(path)
- Return success with removal diff

STEP 3b: Directory Deletion
──────────────────────────────
- Walk directory tree, collect all files with content
- Request single permission (show file count + total lines)
- For each file:
  - Record in history (initial content → "")
  - recordFileWrite(path) + recordFileRead(path)
- os.RemoveAll(dirPath)
- Return success with summary (N files deleted, M total lines removed)
```

### Permission Configuration

```
┌─────────────────────────────────────────────────────┐
│ .opencode.json                                      │
│                                                     │
│ permission.rules.delete ─────────────────┐          │
│   "*": "ask"                             │          │
│   "tmp/*": "allow"                       │          │
│   "*.go": "deny"                         │ Global   │
│                                          │          │
│ agents.coder.permission.delete ──────┐   │          │
│   "*": "ask"                         │   │          │
│   "internal/test/*": "allow"     Agent   │          │
│                                      │   │          │
└──────────────────────────────────────┼───┼──────────┘
                                       │   │
                                       ▼   ▼
                              ┌─────────────────────┐
                              │ evaluateToolPermission│
                              │                     │
                              │ Priority:           │
                              │ 1. Agent-specific   │
                              │ 2. Global           │
                              │ 3. Default: "ask"   │
                              └─────────────────────┘
```

### File Structure

```
internal/llm/tools/
    ├── delete.go            ← new file: delete tool implementation
    └── ...
internal/llm/agent/
    └── tools.go             ← modify: register delete in CoderAgentTools + WorkhorseAgentTools
internal/llm/prompt/
    ├── coder.go             ← modify: add delete tool guidance to prompt
    └── workhorse.go         ← modify: add delete tool guidance to prompt
internal/tui/components/chat/
    └── message.go           ← modify: add delete tool rendering
internal/config/
    └── config.go            ← verify: "delete" works as permission key (no changes expected)
```

## Implementation Plan

### Phase 1: Delete Tool Core

- [x] **1.1** Create `internal/llm/tools/delete.go`:
  - Define `DeleteParams` struct with `Path string` field
  - Define `DeletePermissionsParams` struct with `Path string` and `Diff string` fields
  - Define `DeleteResponseMetadata` struct with `Diff string`, `Removals int`, `FilesDeleted int` fields
  - Define `DeleteToolName = "delete"` constant
  - Define tool description following the pattern of other tools (WHEN TO USE, HOW TO USE, FEATURES, LIMITATIONS, TIPS sections)
  - Implement `deleteTool` struct with dependencies: `permissions permission.Service`, `files history.Service`
  - Implement `NewDeleteTool(permissions, history)` constructor
  - Implement `Info()` method with parameter schema

- [x] **1.2** Implement `Run()` method for file deletion:
  - Parse params, validate path is non-empty
  - Resolve to absolute path via `config.WorkingDirectory()`
  - `os.Stat()` — return error if not exists
  - Check path is within `config.WorkingDirectory()` (security)
  - Get `sessionID` and `messageID` from context
  - For files:
    - Read current content with `os.ReadFile()`
    - Generate diff from content → "" using `diff.GenerateDiff()`
    - Call `evaluateToolPermission(ctx, "delete", absPath)`
    - Handle allow/deny/ask (ask → `permissions.Request()` with diff preview)
    - Record in history: `GetByPathAndSession()` → `Create()` if needed → `CreateVersion(path, "")`
    - `os.Remove(absPath)`
    - `recordFileWrite(absPath)` + `recordFileRead(absPath)`
    - Return success response with diff metadata

- [x] **1.3** Implement `Run()` method for directory deletion:
  - For directories:
    - Walk directory tree with `filepath.Walk()`, collect all file paths and contents
    - Generate summary diff (list of files with line counts)
    - Call `evaluateToolPermission(ctx, "delete", absPath)` on the directory path
    - Handle allow/deny/ask (ask → `permissions.Request()` showing file count and total lines)
    - For each collected file: record in history (initial → "")
    - `os.RemoveAll(absPath)`
    - For each file: `recordFileWrite()` + `recordFileRead()`
    - Return success with summary: files deleted, total lines removed

### Phase 2: Integration

- [x] **2.1** Register delete tool in `internal/llm/agent/tools.go`:
  - Add `tools.NewDeleteTool(permissions, history)` to `CoderAgentTools()` alongside write/edit/patch
  - Add `tools.NewDeleteTool(permissions, history)` to `WorkhorseAgentTools()` (in the `if history != nil` block alongside write/edit/patch)

- [x] **2.2** Update TUI rendering in `internal/tui/components/chat/message.go`:
  - Add `tools.DeleteToolName` case to `toolName()` → return "Delete"
  - Add `tools.DeleteToolName` case to `getToolAction()` → return "Deleting..."
  - Add `tools.DeleteToolName` case to `renderToolParams()` → show the target path
  - Add `tools.DeleteToolName` case to `renderToolResponse()` → show removal diff or summary

### Phase 3: Prompt Updates

- [x] **3.1** Update coder prompt in `internal/llm/prompt/coder.go`:
  - Add guidance: "Use the delete tool to remove files and directories. Do not use `rm` or `rm -rf` in bash for file deletion."
  - Keep it concise — one or two sentences, matching existing prompt style

- [x] **3.2** Update workhorse prompt in `internal/llm/prompt/workhorse.go`:
  - Add same deletion guidance as coder prompt

### Phase 4: Documentation & Testing

- [x] **4.1** Update `AGENTS.md` permission documentation:
  - Add `delete` to the "Supported permission keys" table
  - Add example: `"delete": { "*": "ask", "tmp/*": "allow", "*.go": "deny" }`

- [x] **4.2** Write tests in `internal/llm/tools/delete_test.go`:
  - File deletion: happy path, records history, returns diff metadata
  - Directory deletion: walks tree, records all files, removes directory
  - Validation: empty path, non-existent path, path outside working directory
  - Permission: denied returns error, allowed proceeds without prompt
  - Edge cases: empty file, symlink, read-only file

- [x] **4.3** Generate schema: `go run cmd/schema/main.go > opencode-schema.json`
- [x] **4.4** Run `make test` to verify no regressions

## Edge Cases

### Deleting a File That Was Previously Modified in Session

1. Agent edits `foo.go` (history has initial + v1)
2. Agent then deletes `foo.go`
3. History should add a new version with empty content (v2 = "")
4. Sidebar shows `foo.go` as modified (initial → "")
5. This already works because `CreateVersion(path, "")` is the established pattern from patch tool

### Deleting a Non-Existent File

1. Agent calls delete on a path that doesn't exist
2. `os.Stat()` returns `os.ErrNotExist`
3. Return error response: "File or directory does not exist: /path"
4. No history changes, no permission prompt

### Deleting a Path Outside Working Directory

1. Agent calls delete on `/etc/hosts` or `../../sensitive-file`
2. After resolving to absolute path, check `strings.HasPrefix(absPath, workDir)`
3. Return error response: "Cannot delete files outside the working directory"
4. This is a hard block — not overridable by permissions

### Deleting an Empty Directory

1. Directory exists but contains no files
2. Walk collects zero files
3. Still request permission (the directory itself is being removed)
4. `os.RemoveAll()` succeeds
5. Return success: "Deleted empty directory: /path"

### Deleting a Directory with Nested Directories

1. Directory has subdirectories with files at various depths
2. `filepath.Walk()` collects all files recursively
3. Each file recorded in history individually
4. Single `os.RemoveAll()` removes everything
5. Return summary with total file count

### Symlinks

1. Path points to a symlink
2. `os.Lstat()` can detect symlinks vs `os.Stat()` which follows them
3. **Recommendation**: Use `os.Lstat()` for the initial stat. If it's a symlink, remove the symlink itself (`os.Remove`), don't follow it. Don't record history for the symlink target.

### Permission Denied by OS

1. File exists but user lacks filesystem permissions to delete it
2. `os.Remove()` returns a permission error
3. History was already recorded before the delete attempt
4. **Recommendation**: Attempt the delete before recording history. Or record history after successful delete. The latter is safer — only record what actually happened.

### Large Directory Trees

1. Directory contains thousands of files
2. Walking and recording each file in history could be slow
3. **Recommendation**: Set a reasonable limit (e.g., 500 files). If exceeded, return an error suggesting the agent use bash `rm -rf` for very large cleanups, or confirm with the user first.

## Open Questions

1. **Should the delete tool record history before or after the filesystem deletion?**
   - Before: History reflects intent, but if `os.Remove()` fails, history is incorrect
   - After: History reflects reality, but if the process crashes between delete and history write, the record is lost
   - **Recommendation**: Record history after successful filesystem deletion. Consistency with reality is more important than crash resilience.

2. **Should directory deletions have a file count limit?**
   - No limit: Simple, but agent could accidentally delete thousands of files
   - With limit: Safer, but adds complexity
   - **Recommendation**: Add a soft limit (e.g., 500 files). Above that, return an error with the count and suggest confirmation. This is a safety net, not a hard block.

3. **Should the delete tool remove entries from the in-memory `fileRecords` map?**
   - Keep entries: Stale but harmless (read/write times for non-existent file)
   - Remove entries: Clean, but a recreated file won't have the "modified since last read" check
   - **Recommendation**: Call `recordFileWrite()` + `recordFileRead()` to update timestamps (matching patch tool behavior). Don't delete the entry — it serves as a record that the file was known.

4. **How should the permission prompt display directory deletions?**
   - List all files with individual diffs: Complete but verbose
   - Summary: "Delete directory /path (N files, M total lines)"
   - **Recommendation**: Summary view for the permission prompt. The full file list can be in the tool response.

## Success Criteria

- [x] Delete tool removes files and records changes in `history.Service`
- [x] Delete tool removes directories recursively, recording each file in history
- [x] Deleted files appear in the TUI sidebar with removal diffs
- [x] Permission system supports path-based glob patterns for delete (e.g., `"tmp/*": "allow"`)
- [x] Agent-specific and global permission overrides work for delete tool
- [x] Paths outside `config.WorkingDirectory()` are rejected
- [x] Coder and workhorse prompts instruct agents to use delete tool instead of `rm`
- [x] Delete tool is registered for coder and workhorse agents
- [x] TUI renders delete tool calls with appropriate title, action, params, and response
- [x] `go build ./...` and `go vet ./...` pass
- [x] `make test` passes with no regressions

## References

- `internal/llm/tools/write.go` — Tool implementation pattern (validation, permission, history, in-memory tracking)
- `internal/llm/tools/patch.go` — Delete flow within patch tool (ActionDelete handling, lines 248-294, 346-353)
- `internal/llm/tools/file.go` — In-memory file tracking (`fileRecords`, `recordFileWrite`, `recordFileRead`)
- `internal/llm/tools/tools.go` — `evaluateToolPermission()`, `BaseTool` interface, response types
- `internal/llm/agent/tools.go` — Tool registration for coder/workhorse/explorer agents
- `internal/history/file.go` — `history.Service` interface (Create, CreateVersion, GetByPathAndSession)
- `internal/permission/evaluate.go` — `EvaluateToolPermission()`, `MatchWildcard()`, Action types
- `internal/diff/diff.go` — `GenerateDiff()` for producing removal diffs
- `internal/tui/components/chat/message.go` — TUI tool rendering functions
- `internal/llm/prompt/coder.go` — Coder agent system prompt
- `internal/llm/prompt/workhorse.go` — Workhorse agent system prompt
- `spec/20260207T192153-multiedit-tool-and-edit-improvements.md` — Recent tool spec for format reference
